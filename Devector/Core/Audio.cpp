#include "Audio.h"
#include <algorithm>
#include "Utils/Utils.h"

dev::Audio::Audio(TimerI8253& _timer/*, AYWrapper& aw*/) :
	m_timer(_timer)/*, aywrapper(aw)*/
{
	Init();
}

dev::Audio::~Audio()
{
	Pause(true);
	SDL_DestroyAudioStream(m_stream);
}

void dev::Audio::Pause(bool _pause)
{
	//if (!Options.nosound)
	if (_pause)
	{
		SDL_PauseAudioDevice(m_audioDevice);
	}
	else {
		SDL_ResumeAudioDevice(m_audioDevice);
	}
}

void dev::Audio::Reset()
{
	//aywrapper.reset();
	m_timer.Reset();
}

void dev::Audio::Init()
{
	const SDL_AudioSpec spec = { SDL_AUDIO_F32, 1, 50000 };

	SDL_Init(SDL_INIT_AUDIO);

	if (!(SDL_WasInit(SDL_INIT_AUDIO) & SDL_INIT_AUDIO)) {
		dev::Log("SDL audio error: SDL_INIT_AUDIO not initialized\n");
		return;
	}

	m_stream = SDL_OpenAudioDeviceStream(SDL_AUDIO_DEVICE_DEFAULT_OUTPUT, &spec, Callback, this);
	if (m_stream == NULL) {
		dev::Log("SDL_OpenAudioDeviceStream: the stream failed to create: %s\n", SDL_GetError());
	}

	m_audioDevice = SDL_GetAudioStreamDevice(m_stream);
	if (!m_audioDevice) {
		dev::Log("SDL_GetAudioStreamDevice: the device failed to create: %s\n", SDL_GetError());
	}
	SDL_ResumeAudioDevice(m_audioDevice);
}

// resamples an input audio sample to a lower rate using a linear interpolation.
// _sample the input audio sample to be resampled
// return true if the sample has been resampled, false otherwise 
bool dev::Audio::Resampler(float& _sample)
{
	static int sampleCounter = 0;
	static float accumulator = 0;
	accumulator += _sample;

	if (++sampleCounter > DOWNSAMPLE_FACTOR)
	{
		_sample = accumulator / DOWNSAMPLE_FACTOR;
		sampleCounter = 0;
		accumulator = 0;
		return true;
	}
	return false;
}

// _ticks generated by a 1.5 Mhz timer
void dev::Audio::Tick(int _ticks)
{
	//covox = covox - 255;

	for (int tick = 0; tick < _ticks; ++tick)
	{
		//float ay = aywrapper.step2(2, aych0, aych1, aych2);

		/* timerwrapper does the stepping of 8253, it must always be called */
		float sample = m_timer.Tick(1) /* * Options.volume.timer
			+ (tapeout + tapein) * Options.volume.beeper
			+ Options.volume.covox * (covox / 256.0f)
			+ Options.volume.ay * ay */;

		//if (!Options.nosound)
		{
			if (Resampler(sample))
			{
				//resampler.egg = false;
				Sample(sample);
			}
		}
	}
}

void dev::Audio::Sample(float _sample)
{
	//if (!Options.nosound)
	{
		m_lastValue = _sample;

		m_buffer[m_writeBuffIdx] = _sample;
		// atomic increment in a loop
		m_writeBuffIdx = m_writeBuffIdx == m_bufferSize - 1 ? 0 : m_writeBuffIdx + 1;
	}
}

void dev::Audio::Callback(void* _userdata, SDL_AudioStream* _stream, int _additionalAmount, int _totalAmount)
{
	if (_additionalAmount <= 0) return;

	int len = _additionalAmount / sizeof(float);

	Uint8* data = SDL_stack_alloc(Uint8, _additionalAmount);
	if (data) 
	{
		Audio* that = (Audio*)_userdata;
		float* fstream = (float*)data;

		uint32_t endIdx = (uint32_t(that->m_writeBuffIdx - 1)) % m_bufferSize;
		for (int i = len - 1; i >= 0; i--)
		{
			fstream[i] = that->m_buffer[endIdx];
			endIdx--;
			endIdx %= m_bufferSize;
		}

		SDL_PutAudioStreamData(_stream, data, _additionalAmount);
		SDL_stack_free(data);
	}

	return;
}
